---
title: "Introduction to RGenEDA"
output:
  rmarkdown::md_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Introduction to RGenEDA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.width = 6,
  fig.height = 4
)

suppressPackageStartupMessages({
  library(RGenEDA)
  library(pasilla)
  library(DESeq2)
  library(tidyverse)
  library(ggplot2)
  library(ggtext)
})
```

# Overview

`RGenEDA` is designed to provide a unified, reproducible framework for exploratory data analysis across multiple omics data types.

This vignette introduces the `RGenEDA` package using bulk RNA-seq data from the pasilla dataset.
`RGenEDA` facilitates Exploratory Data Analysis (EDA) for any omics dataset, provided a counts matrix and metadata are available.

While this example focuses on RNA-seq, the workflow can easily be extended to proteomics, metabolomics, or other high-dimensional datasets.

We’ll follow a simplified version of the [deseq2 framework](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) for normalization and use RGenEDA’s functionality to assess variance structure, dimensionality reduction, and sample relationships.


## Load and inspect the data

We begin by loading the `pasilla` dataset, which contains gene-level RNA-seq counts for *Drosophila melanogaster*.
For your own data, you can use `read_csv()` or `fread()` to import counts from a tabular file.

```{r load-data}
datafile <-  system.file( "extdata/pasilla_gene_counts.tsv", package="pasilla" )
count.table <-  read.table( datafile, header=TRUE, row.names=1, quote="", comment.char="" )
head(count.table)

```

## Define metadata

Next, we define the associated sample metadata.
In `pasilla`, samples differ by treatment (condition) and library type (single-end or paired-end).
```{r metadata}

# Set metadata
cond.type <- c("untreated", "untreated", "untreated", "untreated",
               "treated", "treated", "treated")
lib.type  <- c("single-end", "single-end", "paired-end", "paired-end",
               "single-end", "paired-end", "paired-end")

# Create metadata dataframe
meta <- data.frame(
  condition = cond.type,
  library = lib.type
)
rownames(meta) <- colnames(count.table)

# Color palettes for plotting
colorList <- list(
  condition = c("untreated" = "#E41A1C", "treated" = "#377EB8"),
  library   = c("single-end" = "#FF7F00", "paired-end" = "#4DAF4A")
)

head(meta)
```

## Processing and normalization

We next build a `DESeqDataSet` and perform variance-stabilizing transformation (VST) for downstream EDA.
Lowly expressed genes are filtered out before running `DESeq2.`

```{r deseq-prep, message=FALSE}

dds <- DESeqDataSetFromMatrix(
  countData = count.table,
  colData = meta,
  design = ~ condition + library + condition:library
)

# Set reference levels
dds$condition <- relevel(dds$condition, ref = "untreated")
dds$library <- relevel(dds$library, ref = "single-end")

# Prefilter: keep genes with at least 10 counts in ≥3 samples
keep <- rowSums(counts(dds) >= 10) >= 3
dds <- dds[keep,]

# Run DESeq2
dds <- DESeq(dds)

# Variance-stabilizing transform
vsd <- vst(dds)
mat <- assay(vsd)
```

## Create a GenEDA object

With the normalized counts and metadata prepared, we can create a `GenEDA` object.
This object will store all components of your analysis, from normalized data and metadata (bare minimum requirements) to PCA and HVG results (downstream.) Raw counts passed to `DESeq2` can optionally be stored.


```{r build_genEDA, fig.show='hold', out.width='50%', cache = FALSE}

obj <- GenEDA(
  normalized = mat,
  metadata = meta)

# View object summary
obj
```

## Sample-to-sample Eucliden distances with hierarchical clustering

To visualize replicate similarity, we can plot Euclidean distances between samples using the `distanceHeatmap` function.
Darker colors indicate higher similarity, while lighter colors represent dissimilar samples. This provides a quick assessment of replicate quality and metadata features that drive clustering. 

```{r clustering, fig.show='hold', out.width='60%', cache = FALSE}

distanceHeatmap(
  obj,
  meta_cols = c("condition", "library"),
  palettes = colorList,
  return = "plot"
)


```

### Identify highly variable genes (HVGs)

Next, we assess variance across all genes to identify those most variable across samples as these drive much of the biological signal. You can visualize the full variance profile for all genes profiled with `plotHVGVariance`.

```{r hvgs-plot, fig.show='hold', out.width='60%', cache = FALSE}

#----- Plot variance profile
plotHVGVariance(obj)

```

Based on the plot, we’ll retain the top 2,000 most variable genes using `FindVariableFeatures` which stores the gene names in the HVGs slot of the `GenEDA` object

```{r hvgs-find}

#----- Add HVGs to object
obj <- FindVariableFeatures(obj, 2000)
head(HVGs(obj))

```

## Principal component analysis

Using the identified HVGs, we perform PCA with `RunPCA`.
This function stores PCA results in the DimReduction slot, including:

•	`$Loadings` (sample scores)
	
•	`$Eigenvectors` (gene contributions)
	
•	`$percent_var` (Percent variance explained per component, up to PC5)

If `FindVariableFeatures` was not ran beforehand, `RunPCA` will calculate HVGs by default with 2000 features. This argument can be overriden using the `nfeatures` argument. 

```{r run-pca}

obj <- RunPCA(obj)

# Inspect PCA outputs
head(obj@DimReduction$Loadings)
head(obj@DimReduction$Eigenvectors)
head(obj@DimReduction$percent_var)

```

## Extract and visualize PCA results

You can easily extract PCA results merged with metadata using `ExtractPCA`.
This enables flexible downstream visualization with ggplot2 or other frameworks.

To quickly plot PCA results, the `PlotPCA` function can be used. 

```{r extract-pca, fig.show='hold', out.width='70%'}

pcaDF <- ExtractPCA(obj)
head(pcaDF)

# Plot PCA
PlotPCA(object = obj,
        x = 1,
        y = 2,
        color_by = "condition",
        colors = c("untreated" = "red", "treated" = "blue"),
        shape_by = "library")

```

## Correlate PCs with metadata (Eigencorrelation)


To interpret principal components, we can correlate them with sample metadata using eigencorr().
This function computes Pearson correlations and displays them as a heatmap, helping to reveal which metadata features are most associated with major axes of variation. This function returns a list of 4 elements:

•	`$cor_matrix` (Pearson correlation values)
	
•	`$pval_matrix` (Associated correlation p-values)
	
•	`$stars` (asterisk representations of p-values)
	
•	`$plot` (Eigencorr plot, as a `ggplot2` object)


```{r eigencorr, fig.show='hold', out.width='70%'}

ec <- eigencorr(obj, num_pcs = 5)
ec$plot

```

MORE TO COME....
RGenEDA is in active development!
