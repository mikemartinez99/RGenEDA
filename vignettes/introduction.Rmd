---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette will show the basic use-cases for `RGenEDA` on bulk RNASeq data, however, the package can be easily used for other types of omics data as long as a counts matrix and metadata are present. 

We will rely on data in the `pasilla` dataset and follow the [deseq2 framework](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)

```{r setup}

#----- Load libraries
suppressPackageStartupMessages({
  library(RGenEDA)
  library(pasilla)
  library(tidyverse)
  library(ggplot2)
  library(ggtext)
})
```

We first load in our data. In the case of your own data, you can use `read_csv`, `fread`, or your favorite table reader function to load your counts matrix. We will quickly explore the first few rows of the data. 
```{r read in the data}

#----- Set path to pasilla data
datafile <-  system.file( "extdata/pasilla_gene_counts.tsv", package="pasilla" )

#----- Load counts
count.table <-  read.table( datafile, header=TRUE, row.names=1, quote="", comment.char="" )
head(count.table)

```

We need to gather the metadata associated with these samples. In the case of the `pasilla` dataset, we have two major variables: `cond.type` and `lib.type` which we will explore. It is always a good practice to ensure that your samples are not scrambled between your counts matrix and metadata table. 

We will also set a list of color vectors for our metadata which will be useful in downstream functions.
```{r set metadata}

#----- Metadata building
cond.type <-  c( "untreated", "untreated", "untreated","untreated", "treated", "treated", "treated" )
lib.type   <-  c( "single-end", "single-end", "paired-end", "paired-end", "single-end", "paired-end", "paired-end" ) 
meta <- data.frame(condition = cond.type,
                   library = lib.type)
rownames(meta) <- colnames(count.table)

#----- Set color vector list
colorList <- list(condition= c("untreated" = "red",
                                "treated" = "blue"),
                  library = c("single-end" = "orange",
                               "paired-end" = "green"))
```

Now, we can create a DESeq2 object using our counts and metadata. We pre-filter the counts data to remove lowly expressed genes and run DESeq2. We variance stabalize transform the counts to prepre for exploratory data analysis. `rlog` transformation can be used here if preferred. 
```{r prepare for DESeq2}

#----- Create a DESeq2 dataset
dds <- DESeqDataSetFromMatrix(countData = count.table,
                              colData = meta,
                              design = ~condition + library + condition:library)

#----- Set reference levels
dds$condition <- relevel(dds$condition, ref = "untreated")
dds$library <- relevel(dds$library, ref = "single-end")

#----- Pre filter
smallestGroupSize <- 3
keep <- rowSums(counts(dds) >= 10) >= smallestGroupSize
dds <- dds[keep,]

#----- Run DESeq2
dds <- DESeq(dds)

#----- Variance stabilizing transform
vsd <- vst(dds)

#----- Extract matrix
mat <- assay(vsd)
```

Now that we successfully have a matrix and metadata, we are ready to start exploratory data analysis. 
To begin, we create a `GenEDA` object which requires the following slots: normalized counts, which can be obtained through variance stabilizing transformation as shown above, or `rlog` and metadata.

Raw counts can also be provided. Additional slots (`HVGs`, `DimReduction`, and `DEGs` will be filled later.)

```{r build_genEDA, fig.show='hold', out.width='50%', cache = FALSE}

#----- Create new GenEDA object
obj <- GenEDA(normalized = mat,
              metadata = meta,
              counts = as.matrix(count.table))

#----- Visualize the object
obj

#----- Visualize the structure of the object
str(obj)

```

Let's first see how our replicates compare to one another. We can visualize this by using Euclidean distances paired with hierarchical clustering. The `distanceHeatmap` function plots sample-to-sample distances such that darker colors are more similar and lighter colors are more dissimilar. This helps to assess replicate quality as well as metadata features that seem to drive clustering. This function returns either the object, or the plot itself. Any number of metadata categories can be passed along with the associated color vectors. 

```{r clustering, fig.show='hold', out.width='50%', cache = FALSE}

#----- Plot Eucliden distances
distanceHeatmap(obj,
                meta_cols = c("condition", "library"),
                palettes = colorList,
                return = "plot")


```
To begin, we assess the variance profile of our data. This will give us an idea of how many genes are highly variable. This information will inform how principal components are calculated downstream. This can be done one of two ways: `plotHVGVariance` will plot an elbow curve for each gene, ranked by decreasing variance. This is a subjective way to pick a number of highly variable genes (HVGs). We can also use `FindVariableFeatures` directly by providing a number of genes to use, again ranked by decreasing variance. Once calculated, HVGs (gene names) will be stores in the `HVGs` slot of the object.
```{r variance_1, fig.show='hold', out.width='50%', cache = FALSE}

#----- Plot variance profile
plotHVGVariance(obj)

```
Based on our plot, it appears that 2000 variable features should be sufficient to capture the breadth of variation in our data. We can add these HVGs to out object using the `FindVariableFeatures` function specifying the top 2000 features.
```{r variance_2, fig.show='hold', out.width='50%', cache = FALSE}

#----- Add HVGs to object
obj <- FindVariableFeatures(obj, 2000)

#----- View the HVGs
head(HVGs(obj))

```

We can use these HVGs to calculate the principal components of our dataset using the `RunPCA` function. If `FindVariableFeatures` was not ran beforehand, `RunPCA` will calculate HVGs by default with 2000 features. This argument can be overriden using the `nfeatures` argument. The PCA results will be stored in the `DimReduction` slot of the object as a list containing 3 elements: `$Loadings` holding the PCA loadings for each sample, `$Eigenvectors` holding the per-gene loadings for each PC, and `$percent_var` containing the percent variation explained by the top 5 principal components.

Since we have already selected HVGs, we can run `RunPCA` on our object directly and grab the results. 

```{r PCA, fig.show='hold', out.width='50%', cache = FALSE}

#----- Calculate PCA
obj <- RunPCA(obj)

#----- Visualize the results
head(obj@DimReduction$Loadings)
head(obj@DimReduction$Eigenvectors)
head(obj@DimReduction$percent_var)

```

We can access the PCA results and merge with metadata for downstream plotting using the utility function `ExtractPCA`.
Note, a PCA plotting function is in the works, of which an argument `returnData` will be used to run this utility function under the hood.
This can be used directly to facilitate more complex, customizable figure plotting.

```{r PCA_2, fig.show='hold', out.width='50%', cache = FALSE}

#----- Extract PCA results with metadata as a dataframe
pcaDF <- ExtractPCA(obj)

#----- Visualize results
colnames(pcaDF)

```

We can then correlate principal components, which represent major axes of variation, with metadata features through eigenvector correlation plots. The function `eigencorr` uses Pearson correlations to assess significant correlations and plots a heatmap showing these correlations. By default, the principal components from the `DimReduction` slot are used. Any metadata features can be specified using the `meta_cols` argument. By default, all metadata columns will be used. This function returns a list of 4 elements: `cor_matrix` with the Pearson correlation values, `pval_matrix` holding the associated p-values, `stars` holding the star encodings based on significance, and `plot` (ggplot object.)

Here, we will correlate our metadata with the first 5 PCs.

```{r eigencorr, fig.show='hold', out.width='50%', cache = FALSE}

#----- Plot eigenvector correlations
ec <- eigencorr(obj,
                num_pcs = 5)

#----- Visualize the plot
ec$plot

```

MORE TO COME....
RGenEDA is in active development!
