---
title: "Introduction to RGenEDA"
output:
  rmarkdown::html_document:
vignette: >
  %\VignetteIndexEntry{Introduction to RGenEDA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.width = 6,
  fig.height = 4
)

suppressPackageStartupMessages({
  library(RGenEDA)
  library(pasilla)
  library(DESeq2)
  library(tidyverse)
  library(ggplot2)
  library(ggtext)
})
```

# Overview

`RGenEDA` is designed to provide a unified, reproducible framework for exploratory data analysis across multiple omics data types.

This vignette introduces the `RGenEDA` package using bulk RNA-seq data from the pasilla dataset.
`RGenEDA` facilitates Exploratory Data Analysis (EDA) for any omics dataset, provided a counts matrix and metadata are available.

While this example focuses on RNA-seq, the workflow can easily be extended to proteomics, metabolomics, or other high-dimensional datasets.

We’ll follow a simplified version of the [deseq2 framework](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) for normalization and use RGenEDA’s functionality to assess variance structure, dimensionality reduction, and sample relationships.

## Table of contents
- [Load and inspect the data](#load-and-inspect-the-data)
- [Define metadata](#define-metadata)
- [Processing and normalization](#processing-and-normalization)
- [Create a GenEDA object](#create-a-geneda-object)
- [Count distrubutions across samples](#count-distributions-across-samples)
- [Sample Eucliden distances with hierarchical clustering](#sample-euclidean-distances-with-hierarchical-clustering)
- [Identify highly variable genes](#identify-highly-variable-genes)
- [Principal component analysis](#principal-component-analysis)
- [Extract and visualize PCA results](#extract-and-visualize-pca-results)
- [Explore Eigen vectors of individual PCs](#explore-eigen-vectors-of-individual-pcs)
- [Correlate PCs with metadata](#correlate-pcs-with-metadata)

## Load and inspect the data

We begin by loading the `pasilla` dataset, which contains gene-level RNA-seq counts for *Drosophila melanogaster*.
For your own data, you can use `read_csv()` or `fread()` to import counts from a tabular file.

```{r load-data}
datafile <-  system.file( "extdata/pasilla_gene_counts.tsv", package="pasilla" )
count.table <-  read.table( datafile, header=TRUE, row.names=1, quote="", comment.char="" )
head(count.table)

```

## Define metadata

Next, we define the associated sample metadata.
In `pasilla`, samples differ by treatment (condition) and library type (single-end or paired-end).
```{r metadata}

# Set metadata
cond.type <- c("untreated", "untreated", "untreated", "untreated",
               "treated", "treated", "treated")
lib.type  <- c("single-end", "single-end", "paired-end", "paired-end",
               "single-end", "paired-end", "paired-end")

# Create metadata dataframe
meta <- data.frame(
  condition = cond.type,
  library = lib.type
)
rownames(meta) <- colnames(count.table)

# Color palettes for plotting
colorList <- list(
  condition = c("untreated" = "#E41A1C", "treated" = "#377EB8"),
  library   = c("single-end" = "#FF7F00", "paired-end" = "#4DAF4A")
)

head(meta)
```

## Processing and normalization

We next build a `DESeqDataSet` and perform variance-stabilizing transformation (VST) for downstream EDA.
Lowly expressed genes are filtered out before running `DESeq2.`

```{r deseq-prep, message=FALSE}

dds <- DESeqDataSetFromMatrix(
  countData = count.table,
  colData = meta,
  design = ~ condition + library + condition:library
)

# Set reference levels
dds$condition <- relevel(dds$condition, ref = "untreated")
dds$library <- relevel(dds$library, ref = "single-end")

# Prefilter: keep genes with at least 10 counts in ≥3 samples
keep <- rowSums(counts(dds) >= 10) >= 3
dds <- dds[keep,]

# Run DESeq2
dds <- DESeq(dds)

# Variance-stabilizing transform
vsd <- vst(dds)
mat <- assay(vsd)
```

## Create a GenEDA object

With the normalized counts and metadata prepared, we can create a `GenEDA` object.
This object will store all components of your analysis, from normalized data and metadata (bare minimum requirements) to PCA and HVG results (downstream.) Raw counts passed to `DESeq2` can optionally be stored.


```{r build_genEDA, fig.show='hold', out.width='50%', cache = FALSE}

obj <- GenEDA(
  normalized = mat,
  metadata = meta)

# View object summary
obj
```

## Count distributions across samples

To visualize normalized count distributions across samples, the `PlotCountDist` function can be used. This is a helpful way to visualize effectiveness of normalization, as the overall distributions should be similar across samples. Samples with very low or very high overall counts compared to others might indicate problematic samples, technical artifacts, or batch effect. 

```{r count-dist}

PlotCountDist(obj, split_by = "condition")


```


## Sample Eucliden distances with hierarchical clustering

To visualize replicate similarity, we can plot Euclidean distances between samples using the `distanceHeatmap` function.
Darker colors indicate higher similarity, while lighter colors represent dissimilar samples. This provides a quick assessment of replicate quality and metadata features that drive clustering. 

```{r clustering, fig.show='hold', out.width='60%', cache = FALSE}

distanceHeatmap(
  obj,
  meta_cols = c("condition", "library"),
  palettes = colorList,
  return = "plot"
)


```

## Identify highly variable genes

Next, we assess variance across all genes to identify those most variable across samples as these drive much of the biological signal. You can visualize the full variance profile for all genes profiled with `plotHVGVariance`.

```{r hvgs-plot, fig.show='hold', out.width='60%', cache = FALSE}

#----- Plot variance profile
plotHVGVariance(obj)

```

Based on the plot, we’ll retain the top 2,000 most variable genes using `FindVariableFeatures` which stores the gene names in the HVGs slot of the `GenEDA` object

```{r hvgs-find}

#----- Add HVGs to object
obj <- FindVariableFeatures(obj, 2000)
head(HVGs(obj))

```

## Principal component analysis

Using the identified HVGs, we perform PCA with `RunPCA`.
This function stores PCA results in the DimReduction slot, including:

•	`$Loadings` (sample scores)
	
•	`$Eigenvectors` (gene contributions)
	
•	`$percent_var` (Percent variance explained per component, up to PC5)

If `FindVariableFeatures` was not ran beforehand, `RunPCA` will calculate HVGs by default with 2000 features. This argument can be overriden using the `nfeatures` argument. 

```{r run-pca}

obj <- RunPCA(obj)

# Inspect PCA outputs
head(obj@DimReduction$Loadings)
head(obj@DimReduction$Eigenvectors)
head(obj@DimReduction$percent_var)

```

## Extract and visualize PCA results

You can easily extract PCA results merged with metadata using `ExtractPCA`.
This enables flexible downstream visualization with ggplot2 or other frameworks.

To quickly plot PCA results, the `PlotPCA` function can be used. 

```{r extract-pca, fig.show='hold', out.width='70%'}

pcaDF <- ExtractPCA(obj)
head(pcaDF)

# Plot PCA
PlotPCA(object = obj,
        x = 1,
        y = 2,
        color_by = "condition",
        colors = c("untreated" = "red", "treated" = "blue"),
        shape_by = "library")

```
## Explore Eigen vectors of individual PCs

We can explore the individual Eigen vectors that comprise a particular component of interest (usually PC1 and PC2) using `extractEigen`.

Similarly, to visually explore the top Eigen vectors, the `PlotEigenHeatmap` function can be ran directly. Specifying the number of Eigen vectors and whether to show just the top, bottom, or both directions can help elucidate gene signatures driving expression. Heatmap values are the normalized expression values scaled and Z-scored.

```{r eigenvecs, fig.width = 8, fig.height = 6}

pc1_eigen <- extractEigen(object = obj,
                          component = "PC1")

# Plot heatmap
ht <- PlotEigenHeatmap(obj, "PC1", n = 5, annotate_by = c("condition"), 
                       annotate_colors = list(Group = c("untreated" = "red", "treated" = "blue")))

ht$heatmap

```

## Correlate PCs with metadata

To interpret principal components, we can correlate them with sample metadata using `eigencorr`.
This function computes Pearson correlations and displays them as a heatmap, helping to reveal which metadata features are most associated with major axes of variation. This function returns a list of 4 elements:

•	`$cor_matrix` (Pearson correlation values)
	
•	`$pval_matrix` (Associated correlation p-values)
	
•	`$stars` (asterisk representations of p-values)
	
•	`$plot` (Eigencorr plot, as a `ggplot2` object)

**Note:** `ordcorr` can be used for microbiome data as it correlates metadata features with NMDS beta values rather than PCs.


```{r eigencorr, fig.show='hold', out.width='70%'}

ec <- eigencorr(obj, num_pcs = 5)
ec$plot

```

MORE TO COME....
RGenEDA is in active development!
