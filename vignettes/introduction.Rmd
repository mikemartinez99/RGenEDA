---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette will show the basic use-cases for `RGenEDA` on bulk RNASeq data, however, the package can be easily used for other types of omics data as long as a counts matrix and metadata are present. 

We will rely on data in the `pasilla` dataset and follow the [deseq2 framework](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)

```{r setup}
# Load libraries
suppressPackageStartupMessages({
  library(RGenEDA)
  library(pasilla)
  library(tidyverse)
  library(ggplot2)
  library(ggtext)
})
```

We first load in our data. In the case of your own data, you can use `read_csv`, `fread`, or your favorite table reader function to load your counts matrix. We will quickly explore the first few rows of the data. 
```{r read in the data}
# Set path to pasilla data
datafile <-  system.file( "extdata/pasilla_gene_counts.tsv", package="pasilla" )

# Load counts
count.table <-  read.table( datafile, header=TRUE, row.names=1, quote="", comment.char="" )
head(count.table)

```

We need to gather the metadata associated with these samples. In the case of the `pasilla` dataset, we have two major variables: `cond.type` and `lib.type` which we will explore. It is always a good practice to ensure that your samples are not scrambled between your counts matrix and metadata table. 
```{r set metadata}
cond.type <-  c( "untreated", "untreated", "untreated","untreated", "treated", "treated", "treated" )
lib.type   <-  c( "single-end", "single-end", "paired-end", "paired-end", "single-end", "paired-end", "paired-end" ) 

metadata <- data.frame(condition = cond.type,
                       library = lib.type)
rownames(metadata) <- colnames(count.table)
```

Now, we can create a DESeq2 object using our counts and metadata. We pre-filter the counts data to remove lowly expressed genes and run DESeq2. We variance stabalize transform the counts to prepre for exploratory data analysis. `rlog` transformation can be used here if preferred. 
```{r prepare for DESeq2}

# Create a DESeq2 dataset
dds <- DESeqDataSetFromMatrix(countData = count.table,
                              colData = metadata,
                              design = ~condition + library + condition:library)

# Set reference levels
dds$condition <- relevel(dds$condition, ref = "untreated")
dds$library <- relevel(dds$library, ref = "single-end")

# Pre filter
smallestGroupSize <- 3
keep <- rowSums(counts(dds) >= 10) >= smallestGroupSize
dds <- dds[keep,]

# Run DESeq2
dds <- DESeq(dds)

# Variance stabilizing transform
vsd <- vst(dds)

# Extract matrix
mat <- assay(vsd)
```

Now that we successfully have a matrix and metadata, we are ready to start exploratory data analysis. 
Let's start by looking at the sample distances to see how our samples are clustering. For `RGenEDA` it is useful to set a figure directory where all EDA plots will live. We want to visualize all possible metadata for this. 

```{r sample distances, fig.show='hold', out.width='50%', cache = FALSE}

# Set output directory
outputDir <- c("/users/mike/Desktop/RGenEDA/img/")

# Set colors for our metadata categories
metaColors <- list(condition = c("untreated" = "blue",
                                 "treated" = "red"),
                   library = c("single-end" = "maroon",
                               "paired-end" = "gold"))

# Call the distance heatmap function
distanceHeatmap(MAT = mat,
                META = metadata,
                FEATURES = c("condition", "library"),
                PALETTES = metaColors,
                OUTPUT = outputDir)

knitr::include_graphics(file.path(outputDir, "Sample_Distance_HM.tiff"))


```

```{r run PCA functions}

# Explore variance
variance <- plotVariance(MAT = mat,
                         OUTPUT = outputDir,
                         LOG = FALSE,
                         nFeaturesDrop = NULL)

# Generate PCs
pcaRes <- generatePCs(MAT = mat,
                      VARS = variance,
                      NFEATURES = 2000)

# Extract PC data
pcaDF <- as.data.frame(pcaRes[["Loadings"]])

# Append metadata to pcaDF
pcaDF <- cbind(pcaDF, metadata)

# Plot PCA
```


Eigencorrelations can be used to assess what metadata features are strongly correlated with major axes of variation in the data. `eigencorr` produces a list of 3, including the correlation matrix, the p-value matrix, and the significance stars such that three stars < 0.001, two stars < 0.01, and one star < 0.05. No Star indicates no significance. 
```{r eigencorrelations, fig.show='hold', out.width='50%', cache = FALSE}

# Use Eigencorrelations
eigenRes <- eigencorr(MAT = mat,
          META = metadata,
          NUM_PCS = 4,
          OUTPUT = outputDir)

eigenRes[[""]]

knitr::include_graphics(file.path(outputDir, "EigenCorrelations.tiff"))
```

After finding principal components that correlate with metadata features of interest, we can then explore the loadings for that particular principal component using the variances and pca results calculated above from `plotVariance` and `generatePCs`, respectively. We specify PC1 as the component of interest and provide the same number of features we used to calculate out principal components. This function returns a dataframe of the gene, its loading, and the percentage of variation it contributes to the particular component specified. We can use these loadings to plot figures showing the gene contributions.

```{r extractloadings, fig.show='hold', cache = FALSE}
PC1_loadings <- extractLoadings(variance = variance, 
                                pcRes = pcaRes,
                                component = "PC1",
                                nfeatures = 2000)

# Specify number of genes to take from top and bottom of loadings
top_n <- 20
df_plot <- PC1_loadings %>%
  arrange(desc(Loading)) %>% slice(1:top_n) %>%
  bind_rows(PC1_loadings %>% arrange(Loading) %>% slice(1:top_n)) %>%
  mutate(Direction = ifelse(Loading > 0, "Positive", "Negative"),
         Gene = fct_reorder(Gene, Loading))  

# Plot
ggplot(df_plot, aes(x = Gene, y = Loading, color = Loading, size = PercentVariance)) +
  geom_point(alpha = 0.9, shape = 21, stroke = 0.8, fill = "white", show.legend = c(size = TRUE, color = FALSE)) +
  scale_color_gradient2(low = "firebrick", mid = "white", high = "dodgerblue", midpoint = 0, guide = "none") +
  scale_size_continuous(range = c(4, 12)) +
  coord_flip() +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.y = element_text(face = "bold", size = 12, color = "#222222"),
    axis.title = element_text(size = 14, face = "bold"),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_line(color = "#eeeeee"),
    plot.title = element_markdown(face = "bold", size = 18),
    plot.subtitle = element_markdown(size = 14),
    legend.position = "right",
    legend.title = element_text(face = "bold")
  ) +
  labs(
    title = "<span style='color:dodgerblue'>Top Positive</span> & <span style='color:firebrick'>Negative</span> PCA Loadings",
    subtitle = "Circle size = contribution to PC variance",
    x = NULL,
    y = "Loading",
    size = "Percent Variance"
  )




```

After our exploration, we can examine our differential expression results using an MA plot. 
```{r MA plot}
# Extract DESeq2 results
resultsNames(dds)
results <- as.data.frame(results(dds, name = "condition_treated_vs_untreated"))

x <- MAplot(results = results,
       numerator = "treated",
       refLevel = "untreated",
       log2FC_thresh = 1,
       padj_thresh = 0.05,
       title = "MA_demo",
       figDir = outputDir,
       "MAplotDemo.png")

```
